AAAAAAAAAA
/@~
-*2
+*/
-321
423{}
[]
&??:'!
!#asdfghjjkl
qwertyyuiop
1234567890
/*-+
ASFDGHJKL
QWERTYUIOP
ZXCVBNM<>?
qwertyuiopasdfghjklzxcvbnm
=-_|\\/

Алгоритм Хаффмана
Алгоритм Хаффмана (англ. Huffman's algorithm) — алгоритм оптимального префиксного кодирования алфавита. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы. Используется во многих программах сжатия данных, например, PKZIP 2, LZH и др.

Содержание
1	Определение
2	Алгоритм построения бинарного кода Хаффмана
2.1	Время работы
2.2	Пример
3	Корректность алгоритма Хаффмана
4	См. также
5	Источники информации
Определение
Определение:
Пусть A={a1,a2,…,an} — алфавит из n различных символов, W={w1,w2,…,wn} — соответствующий ему набор положительных целых весов. Тогда набор бинарных кодов C={c1,c2,…,cn}, где ci является кодом для символа ai, такой, что:
ci не является префиксом для cj, при i≠j,
cумма ∑i∈[1,n]wi⋅|ci| минимальна (|ci| — длина кода ci),
называется кодом Хаффмана.

Алгоритм построения бинарного кода Хаффмана
Построение кода Хаффмана сводится к построению соответствующего бинарного дерева по следующему алгоритму:

Составим список кодируемых символов, при этом будем рассматривать один символ как дерево, состоящее из одного элемента c весом, равным частоте появления символа в строке.
Из списка выберем два узла с наименьшим весом.
Сформируем новый узел с весом, равным сумме весов выбранных узлов, и присоединим к нему два выбранных узла в качестве детей.
Добавим к списку только что сформированный узел вместо двух объединенных узлов.
Если в списке больше одного узла, то повторим пункты со второго по пятый.
Время работы
Если сортировать элементы после каждого суммирования или использовать приоритетную очередь, то алгоритм будет работать за время O(NlogN).Такую асимптотику можно улучшить до O(N), используя обычные массивы.

Пример

Дерево Хаффмана для слова abracadabra
Закодируем слово abracadabra. Тогда алфавит будет A={a,b,r,c,d}, а набор весов (частота появления символов алфавита в кодируемом слове) W={5,2,2,1,1}:

В дереве Хаффмана будет 5 узлов:

Узел	a	b	r	с	d
Вес	5	2	2	1	1
По алгоритму возьмем два символа с наименьшей частотой — это c и d. Сформируем из них новый узел cd весом 2 и добавим его к списку узлов:

Узел	a	b	r	cd
Вес	5	2	2	2
Затем опять объединим в один узел два минимальных по весу узла — r и cd:

Узел	a	rcd	b
Вес	5	4	2
Еще раз повторим эту же операцию, но для узлов rcd и b:

Узел	brcd	a
Вес	6	5
На последнем шаге объединим два узла — brcd и a:

Узел	abrcd
Вес	11
Остался один узел, значит, мы пришли к корню дерева Хаффмана (смотри рисунок). Теперь для каждого символа выберем кодовое слово (бинарная последовательность, обозначающая путь по дереву к этому символу от корня):

Символ	a	b	r	с	d
Код	0	11	101	1000	1001
Таким образом, закодированное слово abracadabra будет выглядеть как 01110101000010010111010. Длина закодированного слова — 23 бита. Стоит заметить, что если бы мы использовали алгоритм кодирования с одинаковой длиной всех кодовых слов, то закодированное слово заняло бы 33 бита, что существенно больше.

Корректность алгоритма Хаффмана
Чтобы доказать корректность алгоритма Хаффмана, покажем, что в задаче о построении оптимального префиксного кода проявляются свойства жадного выбора и оптимальной подструктуры. В сформулированной ниже лемме показано соблюдение свойства жадного выбора.

Лемма (1):
Пусть C — алфавит, каждый символ c∈C которого встречается с частотой f[c]. Пусть x и y — два символа алфавита C с самыми низкими частотами. Тогда для алфавита C существует оптимальный префиксный код, кодовые слова символов x и y в котором имеют одинаковую максимальную длину и отличаются лишь последним битом.
Доказательство:
▹
Возьмем дерево T, представляющее произвольный оптимальный префиксный код для алфавита C. Преобразуем его в дерево, представляющее другой оптимальный префиксный код, в котором символы x и y — листья с общим родительским узлом, находящиеся на максимальной глубине.

Пусть символы a и b имеют общий родительский узел и находятся на максимальной глубине дерева T. Предположим, что f[a]⩽f[b] и f[x]⩽f[y]. Так как f[x] и f[y] — две наименьшие частоты, а f[a] и f[b] — две произвольные частоты, то выполняются отношения f[x]⩽f[a] и f[y]⩽f[b]. Пусть дерево T′ — дерево, полученное из T путем перестановки листьев a и x, а дерево T′′ — дерево полученное из T′ перестановкой листьев b и y. Разность стоимостей деревьев T и T′ равна:

B(T)−B(T′)=∑c∈Cf(c)dT(c)−∑c∈Cf(c)dT′(c)=(f[a]−f[x])(dT(a)−dT(x)),

что больше либо равно 0, так как величины f[a]−f[x] и dT(a)−dT(x) неотрицательны. Величина f[a]−f[x] неотрицательна, потому что x — лист с минимальной частотой, а величина dT(a)−dT(x) является неотрицательной, так как лист a находится на максимальной глубине в дереве T. Точно так же перестановка листьев y и b не будет приводить к увеличению стоимости. Таким образом, разность B(T′)−B(T′′) тоже будет неотрицательной.

Таким образом, выполняется неравенство B(T′′)⩽B(T). С другой стороны, T — оптимальное дерево, поэтому должно выполняться неравенство B(T)⩽B(T′′). Отсюда следует, что B(T)=B(T′′). Значит, T′′ — дерево, представляющее оптимальный префиксный код, в котором символы x и y имеют одинаковую максимальную длину, что и доказывает лемму.
◃
Лемма (2):
Пусть дан алфавит C, в котором для каждого символа c∈C определены частоты f[c]. Пусть x и y — два символа из алфавита C с минимальными частотами. Пусть C′ — алфавит, полученный из алфавита C путем удаления символов x и y и добавления нового символа z, так что C′=C∖{x,y}∪z. По определению частоты f в алфавите C′ совпадают с частотами в алфавите C, за исключением частоты f[z]=f[x]+f[y]. Пусть T′ — произвольное дерево, представляющее оптимальный префиксный код для алфавита C′ Тогда дерево T, полученное из дерева T′ путем замены листа z внутренним узлом с дочерними элементами x и y, представляет оптимальный префиксный код для алфавита C.
Доказательство:
▹
Сначала покажем, что стоимость B(T) дерева T может быть выражена через стоимость B(T′) дерева T′. Для каждого символа c∈C∖{x,y} верно dT(C)=dT′, значит, f[c]dT(c)=f[c]dT′(c). Так как dT(x)=dT(y)=dT′(z)+1, то

f[x]dT(x)+f[y]dT(y)=(f[x]+f[y])(dT′(z)+1)=f[z]dT′(z)+(f[x]+f[y])

из чего следует, что

B(T)=B(T′)+f[x]+f[y]

или

B(T′)=B(T)−f[x]−f[y]

Докажем лемму от противного. Предположим, что дерево T не представляет оптимальный префиксный код для алфавита C. Тогда существует дерево T′′ такое, что B(T′′)<B(T). Согласно лемме (1), элементы x и y можно считать дочерними элементами одного узла. Пусть дерево T′′′ получено из дерева T′′ заменой элементов x и y листом z с частотой f[z]=f[x]+f[y]. Тогда

B(T′′′)=B(T′′)−f[x]−f[y]<B(T)−f[x]−f[y]=B(T′),

что противоречит предположению о том, что дерево T′ представляет оптимальный префиксный код для алфавита C′. Значит, наше предположение о том, что дерево T не представляет оптимальный префиксный код для алфавита C, неверно, что и доказывает лемму.
◃
Теорема:
Алгоритм Хаффмана дает оптимальный префиксный код.
Доказательство:
▹
Справедливость теоремы непосредственно следует из лемм (1) и (2)
◃
См. также
Оптимальное хранение словаря в алгоритме Хаффмана
Источники информации
Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ — 2-е изд. — М.: «Вильямс», 2007. — с. 459. — ISBN 5-8489-0857-4
Wikipedia — Huffman coding
Википедия — Бинарное дерево
Википедия — Префиксный код
Категории: Дискретная математика и алгоритмыАлгоритмы сжатия
Навигация
Вы не представились системеОбсуждениеВкладСоздать учётную записьВойтиСтатьяОбсуждениеЧитатьПравитьИсторияПоиск
Искать в Викиконспекты
Заглавная страница
Свежие правки
Случайная статья
Справка
Инструменты
Ссылки сюда
Связанные правки
Спецстраницы
Версия для печати
Постоянная ссылка
Сведения о странице
Эта страница последний раз была отредактирована 27 марта 2016 в 15:14.
Политика конфиденциальностиО ВикиконспектыОтказ от ответственностиМобильная версияPowered by MediaWikipackage com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}

package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;


import java.io.IOException;

public class Assignment14Part1 {

    public static void main(String[] args) throws InterruptedException, IOException {
        long start = System.currentTimeMillis();
        //new HeadCreator("assets/BreakoutExt.txt");
        new Unarchivate("assets/BreakoutExt.txt.par");
        System.out.println("RunTime: " + (start - System.currentTimeMillis()) + " ms");

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

public class HeadCreator {
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);

    //todo замінить на інтеджер із 0xff
    ConcurrentHashMap<Byte, Byte> uniqueBytes;
    String fileName;
    static boolean fileFullyRead;

    public HeadCreator(String fileName) throws InterruptedException {
        uniqueBytes = new ConcurrentHashMap<>();
        this.fileName = fileName;
        fileFullyRead = false;
        new Thread(() -> readFile(fileName)).start();
        ExecutorService executorService = Executors.newFixedThreadPool(6);
        while (!queue.isEmpty() || !fileFullyRead) {
            byte[] finalBuffer = queue.take();
            executorService.submit(() -> {
                for (byte oneByte : finalBuffer) {
                    uniqueBytes.putIfAbsent(oneByte, (byte) 1);
                }
            });
        }
        executorService.shutdown();
        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);

        System.out.println(uniqueBytes.size());
        assignValue();

    }

    private void assignValue() {
        int size = (int) Math.ceil(StrictMath.log(uniqueBytes.size()) / StrictMath.log(2.0));
//        System.out.println("size " + size);
        int counter = 0;
        HashMap<Byte, byte[]> newUniqueBytes = new HashMap<>();
        for (byte bytes : uniqueBytes.keySet()) {
//            System.out.println(chars+"" +Arrays.toString(toByteArray(Integer.toBinaryString(counter), size)));
            newUniqueBytes.put(bytes, toByteArray(Integer.toBinaryString(counter++), size));
        }
        uniqueBytes.clear();
        //System.out.println(newUniqueBytes);
        for(byte bt : newUniqueBytes.keySet()){
            System.out.print(bt);
            System.out.print(Arrays.toString(newUniqueBytes.get(bt))+"|  ");
        }
        new Archivate(fileName, newUniqueBytes);
    }

    private byte[] toByteArray(String code, int arraySize) {
        byte[] byteArray = new byte[arraySize];
        //System.out.println("ar size"+arraySize);
        char[] codeChars = code.toCharArray();
        int i = codeChars.length - 1, y = byteArray.length - 1;
        while (i >= 0) {
            byteArray[y--] = Byte.parseByte(String.valueOf(codeChars[i--]));
        }
        return byteArray;
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileFullyRead = true;
        } catch (IOException | InterruptedException exception) {
            exception.printStackTrace();
        }
    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.*;

public class Archivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private ArrayBlockingQueue<Byte> bitsQueue;
    private ArrayBlockingQueue<byte[]> bytesQueue;
    private ArrayBlockingQueue<byte[]> queue = new ArrayBlockingQueue<>(8);
    private HashMap<Byte, byte[]> associationTable;
    FileOutputStream fileOutputStream;
    BufferedOutputStream outputStream;
    private long dataByteCounter = 0;
    private int tableByteCounter = 0;
    String archivedFileName;
    String fileName;

    public Archivate(String fileName, HashMap<Byte, byte[]> associationTable) {
        this.fileName = fileName;
        archivedFileName = fileName + ".par";
        this.associationTable = associationTable;
        try {
            fileOutputStream = new FileOutputStream(archivedFileName);
            writeAssociationTable();
            outputStream = new BufferedOutputStream(fileOutputStream);
            startArchiving();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }

    private void writeAssociationTable() {
        DataOutputStream outputStream = new DataOutputStream(fileOutputStream);
        try {
            outputStream.writeInt(associationTable.size() * 2);
            outputStream.writeLong(0);
            for (Byte oneByte : associationTable.keySet()) {
                outputStream.write(oneByte);
                outputStream.write(bitsToByte(associationTable.get(oneByte)));
                tableByteCounter += 2;
            }
            outputStream.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private int bitsToByte(byte[] bitSet) {
        //замінив тіп на інт
        int result = 0;
        for (int i = 0, pow = bitSet.length - 1; i < bitSet.length; i++, pow--) {
            result += Math.pow(2, pow)*bitSet[i];
        }
        //System.out.println(result);
        return result;
    }

    private void startArchiving() {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        bytesQueue = new ArrayBlockingQueue<>(8192);

        new Thread(() -> readFile(fileName)).start();
        new Thread(() -> {
            while (!queue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = queue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        //System.out.println(bytes);
                        byte[] bitSet = associationTable.get(bytes);
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;
        }).start();
        new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[8];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == 8) {
                        bytesQueue.put(oneByte);
                        oneByte = new byte[8];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (bitCounter > 0) {
                try {
                    bytesQueue.put(oneByte);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBytesAdded = true;
        }).start();
        Thread byteWriter = new Thread(this::writeToFile);
        byteWriter.start();
        try {
            byteWriter.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        try (RandomAccessFile file = new RandomAccessFile(archivedFileName, "rw")) {
            //file.writeInt(tableByteCounter);
            file.seek(4);
            file.writeLong(dataByteCounter);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    private void readFile(String fileName) {
        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(fileName))) {
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = inputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                queue.put(buffer);
            }
            if (readBytesCount > 0) {
                queue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }

    private void writeToFile() {
        byte[] oneByte;
        int result;
        while (!allBytesAdded || !bytesQueue.isEmpty()) {
            dataByteCounter++;
            try {
                oneByte = bytesQueue.take();
                result = ((oneByte[0] << 7)
                        | (oneByte[1] << 6)
                        | (oneByte[2] << 5)
                        | (oneByte[3] << 4)
                        | (oneByte[4] << 3)
                        | (oneByte[5] << 2)
                        | (oneByte[6] << 1)
                        | (oneByte[7]));
                outputStream.write(result);
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
            }
        }
        try {
            outputStream.flush();
            outputStream.close();
            fileOutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
package com.shpp.p2p.cs.ysalenko.assignment14;

import java.io.*;
import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;

public class Unarchivate {
    static boolean fileReadFully = false;
    static boolean allBitsAdded = false;
    static boolean allBytesAdded = false;
    private long dataByteCounter = 0;
    int tableByteCounter;
    //FileOutputStream fileOutputStream;
    DataInputStream inputStream;
    DataOutputStream outputStream;
    String unArchivedFileName;
    private ArrayBlockingQueue<Byte> bitsQueue;
    //todo made changes to byte
    private ConcurrentHashMap<Integer, Byte> associationTable;
    private ArrayBlockingQueue<byte[]> bytesQueue = new ArrayBlockingQueue<>(8);


    public Unarchivate(String fileName) {
        associationTable = new ConcurrentHashMap<>();
        unArchivedFileName = fileName.substring(0, fileName.lastIndexOf(".par"));
        try {
            inputStream = new DataInputStream(new FileInputStream(fileName));
            int bitSetLength = getTechnicalData();
            outputStream = new DataOutputStream(new FileOutputStream(unArchivedFileName));
            startUnArchiving(bitSetLength);

        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private void startUnArchiving(int bitSetLength) {
        bitsQueue = new ArrayBlockingQueue<>(65536);
        new Thread(this::readData).start();
        new Thread(() -> {
            while (!bytesQueue.isEmpty() || !fileReadFully) {
                try {
                    byte[] buffer = bytesQueue.take();
                    //System.out.println(Arrays.toString(buffer));
                    for (byte bytes : buffer) {
                        byte[] bitSet = getBitsSet(bytes);
                        System.out.println(Arrays.toString(bitSet));
                        for (byte bit : bitSet) {
                            bitsQueue.put(bit);
                            //System.out.print(bit);
                        }
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            allBitsAdded = true;

        }).start();
        Thread writeBytes = new Thread(() -> {
            int bitCounter = 0;
            byte[] oneByte = new byte[bitSetLength];
            try {
                while (!allBitsAdded || !bitsQueue.isEmpty()) {
                    oneByte[bitCounter++] = bitsQueue.take();
                    if (bitCounter == bitSetLength) {
//                        System.out.println("oneByte " + Arrays.toString(oneByte));
//                        System.out.println("bitSet "+bitSetToByte(oneByte));
                        //todo check for correct
                        outputStream.writeByte(associationTable.get(bitSetToByte(oneByte)));
                        oneByte = new byte[bitSetLength];
                        bitCounter = 0;
                    }
                }
            } catch (InterruptedException | IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
//            if (bitCounter > 0) {
//                try {
//                    bytesQueue.put(oneByte);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
//            }
            allBytesAdded = true;
        });
        writeBytes.start();
        try {
            writeBytes.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private int bitSetToByte(byte[] bitSet) {
        int result = 0;
        for (int i = 0, j = bitSet.length - 1; i < bitSet.length; i++, j--) {
            result = (result | (bitSet[i] << j));
        }
        return result;
    }

    private int getTechnicalData() throws IOException {
        tableByteCounter = inputStream.readInt();
        dataByteCounter = inputStream.readLong();
        int counter = 0, max = 0;
        while (counter < tableByteCounter) {
            byte key = inputStream.readByte();
            int value = inputStream.read();
            //todo simplify
            if ((value ) > max) {
                //System.out.println(value);
                max = value ;
                //System.out.println(max);
            }
            //System.out.println("key " + value + "  value " + key);
            associationTable.put(value, key);
            counter += 2;
        }

        max = Integer.toBinaryString(max).length();
        System.out.println("max" + max);
        return max;

    }

    //todo made change to int
    private byte[] getBitsSet(byte oneByte) {
        int intByte = oneByte & 0xff;
        //System.out.println("byte " + oneByte + " intB " + intByte);
        byte[] bitsSet = new byte[8];
        //todo fix this shit
        for (int i = 7; i >= 0; i--) {
            bitsSet[i] = (byte) Math.ceil(intByte % 2);
            intByte /= 2;
        }
        return bitsSet;
    }

    private void readData() {
        try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream)) {
            //bufferedInputStream.skip(4 + 8 + tableByteCounter);
            //todo замінить інпут стрім на буферний
            int bufferSize = 8192, readBytesCount;
            byte[] buffer = new byte[bufferSize];
            while ((readBytesCount = bufferedInputStream.read(buffer, 0, bufferSize)) == bufferSize) {
                System.out.println(Arrays.toString(buffer));
                bytesQueue.put(buffer);
            }
            if (readBytesCount > 0) {
                bytesQueue.put(Arrays.copyOfRange(buffer, 0, readBytesCount));
            }
            fileReadFully = true;
        } catch (IOException | InterruptedException exception) {
            System.exit(-1);
            exception.printStackTrace();
        }
    }
}
javatalks - Форум Java программистовjavatalks.ru
Регистрация
Войти
Русский
Поиск
Статьи javatalks
Преобразование byte (-128...127) в int (0...255)
Форум/
Язык Java/
Основы языка Java
 
14 янв 2012 15:32
 
Mako


 
Сообщения:86
Тривиальное решение:
byte bits8 = 127
int bits32 = 128 + (int)bits8

Однако такой метод имеет два существенных недостатка:
1. Полученное 32-битное число не равно исходному 8-битному. Например, 127 = 01111111. А получится 128+127 = 255 = 11111111
Хотя для моей проги это несущественно. Главное, что каждому значению переменной bits8 будет соответсвовать одно, и только одно значение переменной bits32. Причём обязательно в диапазоне 0...255.
Но всё же идеальным было бы такое преобразование, которое порождало бы точно такое же число, если рассматривать исходные 8 бит переменной типа byte как 8-битное беззнаковое число от 0 до 255.

2. Множество лишних преобразований. Понятно, что они "зашиты" прямо в стандарт Джава, но это не отменяет того факта, что на них тратится время. Было бы проще как-то "перенести" те же самые биты.

Например, из числа -1 = 11111111 = 255 при преобразовании из byte в int получится
10000000 00000000 00000000 01111111
А меня вполне устроит 00000000 00000000 00000000 11111111 = 255

Понятно, что при этом старшие 24 бита всегда будут нулевыми, а значит, мы автоматически получаем число из диапазона 0...255.
Вы не поверите, но Java - самый низкоуровневый из изучаемых мною языков.
14 янв 2012 15:50
 
Jedi


 
Сообщения:31
Если все же заниматься преобразованиями, то можно, например, отразить лишь отрицательные, а неотрицательные не трогать. Т.е. [-128;0) -> [128;255]
15 янв 2012 07:55
 
Mako


 
Сообщения:86
Jedi:
Если все же заниматься преобразованиями, то можно, например, отразить лишь отрицательные, а неотрицательные не трогать. Т.е. [-128;0) -> [128;255]


Да, действительно, к искомому результату приведёт такой код:

bits32 = (int)bits8;
if ( bits32 < 0 ) bits32+=256;

Но это, как я говорил, должно быть неэффективно. Кажется, есть какие-то способы "вытянуть" из числа его двоичное представление. Например, чтобы записать в файл с данными. И, соответственно, сформировать число из соответствующего количества байтов.
Вы не поверите, но Java - самый низкоуровневый из изучаемых мною языков.
15 янв 2012 10:53
 
Mam(O)n


 
Сообщения:2190
int bits32 = (int) bits8 & 0xff
15 янв 2012 11:01
 
Mako


 
Сообщения:86
Mam(O)n:
int bits32 = (int) bits8 & 0xff


В результате бит знака потеряется и получится число от 0 до 127.
Вы не поверите, но Java - самый низкоуровневый из изучаемых мною языков.
15 янв 2012 11:09
 
Mam(O)n


 
Сообщения:2190
Ну а проверить слабо? Я этот трюк не с потолка же взял. Да, и кстати приведение (int) там погоды никакой не делает, его можно убрать.
15 янв 2012 11:48
 
Mako


 
Сообщения:86
Mam(O)n:
Ну а проверить слабо? Я этот трюк не с потолка же взял.


Признаю свою ошибку.

Quote:
Да, и кстати приведение (int) там погоды никакой не делает, его можно убрать.


Была такая мысль, но я предпочитаю указывать явно, чтобы не запутаться. Надеюсь, компилятор не будет приводить два раза?
Вы не поверите, но Java - самый низкоуровневый из изучаемых мною языков.
15 янв 2012 11:58
 
Mam(O)n


 
Сообщения:2190
Mako:
Надеюсь, компилятор не будет приводить два раза?
Нет, не будет.
 
Модераторы:frymock
Сейчас эту тему просматривают:Нет
2006 - 2019 © javatalks.ru
Powered by JCommune 3.12.3171.84d20db byjtalks.org
Design withTwitter Bootstrap
При возникновении технических проблем, пишите: project@jtalks.org
TranslatorsCafe.com
Конвертер величин
Перевести единицы измерения из одной системы в другую — запросто!
ПопулярныеМеханикаТеплотаЖидкостиЗвукСветЭлектротехникаМагнетизмРадиацияДругиеКалькуляторы Russian (Russia)
Random converter

Перевести единицы: десятичное в двоичное

Исходная величина
двоичноевосьмеричноедесятичноешестнадцатеричноеоснование 2основание 3основание 4основание 5основание 6основание 7основание 8основание 9основание 10основание 11основание 12основание 13основание 14основание 15основание 16основание 17основание 18основание 19основание 20основание 21основание 22основание 23основание 24основание 25основание 26основание 27основание 28основание 29основание 30основание 31основание 32основание 33основание 34основание 35основание 36
Десятичная система — позиционная система счисления с основанием 10. В этой системе для записи любого числа используются символы 0–9. Эта система наиболее широко использовалась во всех современных цивилизациях.
Преобразованная величина
двоичноевосьмеричноедесятичноешестнадцатеричноеоснование 2основание 3основание 4основание 5основание 6основание 7основание 8основание 9основание 10основание 11основание 12основание 13основание 14основание 15основание 16основание 17основание 18основание 19основание 20основание 21основание 22основание 23основание 24основание 25основание 26основание 27основание 28основание 29основание 30основание 31основание 32основание 33основание 34основание 35основание 36
Двоичная система — позиционная система счисления с основанием 2. В этой системе числа записываются с помощью двух символов 0 и 1. Двоичная система используется во всех цифровых устройствах, таких как компьютеры и мобильные телефоны, так как ее проще всего реализовать в цифровой схемотехнике с помощью логических вентилей.
Пример: в двоичной системе двойка записывается как 10 и десять записывается как 1010.
Электрический ток
Знаете ли вы, что электрический ток можно измерить осциллографом? Один щелчок — и вы узнаете как это делается!

Подробнее о числах
Общие сведения

Различные способы представления чисел

Арабские цифры

Римские цифры

Системы счисления в других культурах

Единичная система счисления

Позиционная система счисления

Двоичная система

Классы чисел

Отрицательные числа

Рациональные числа

Натуральные числа

Целые числа

Комплексные числа

Простые числа

Интересные факты о числах

Особая система записи чисел, чтобы предотвратить мошенничество

Современный счет в торговле

Произношение названий чисел

Несчастливые числа

Изучайте технический русский язык с этим видео! — Learn technical Russian with this video!

Общие сведения
Калькулятор на iPhone
Калькулятор на iPhone
Число — это абстрактное математическое понятие обозначающее количество. Числа используются для счета. Числа использовались человеком с древнейших времен, вначале в виде счетных палочек или зарубок и черточек на дереве и кости, а потом и в виде более абстрактных систем. Существует много способов выражения чисел и работы с ними; некоторые из них приведены ниже. Системы счисления эволюционировали на протяжении многих веков и не все из них используются по сей день.

Различные способы представления чисел
Ученые считают, что понятие числа возникло в разных культурах независимо. Символы для обозначения цифр в письменном виде также возникли в каждой культуре отдельно, но постепенно, с развитием торговли, люди начали обмениваться идеями и заимствовать друг у друга принципы счисления или написания чисел. Поэтому те системы счисления, которыми мы сейчас пользуемся, создавались коллективно многими народами.

Арабские цифры
Арабская система счисления — одна из самых широко используемых систем счисления. Она была заимствована из Индии и доработана персидскими и арабскими математиками. В русском языке эта система называется в основном «арабской», но на других языках, например английском, она чаще называется «индо-арабской». В средние века, особенно ближе к середине и концу этого периода, торговля распространилась по всему миру, и купцы стали привозить в другие страны не только товары, но и сведения о науках, таких как математика. Благодаря этому арабские цифры начали использовать в Европе, сначала в монастырях, а позже и в светском обществе. Папа римский Сильвестр II одним из первых стал использовать и распространять арабские цифры взамен римских, познакомившись с ними благодаря связям с арабскими государствами на территории нынешней Испании. Европейские ученые приспособили и частично изменили написание цифр, и арабская система счисления получила широкое применение не только во всей Европе, но и по всему миру благодаря торговле и во время колонизации других континентов. Арабская система — десятичная, то есть с основанием 10 и с использованием десяти цифр, которыми можно выразить все возможные числа.

Десять — одно из наиболее широко используемых чисел в системах счета, и десятичная система распространена во многих странах. Это связано с тем, что издревле люди пользовались десятью пальцами на руках для счета. До сих пор люди, которые учатся считать или хотят проиллюстрировать пример, связанный со счетом, используют пальцы. Существуют даже такие выражения как «считать на пальцах». В некоторых культурах для счета использовали также и пальцы ног, костяшки пальцев, и даже пространство между пальцами. Интересно, что во многих языках слово, обозначающее пальцы и цифры — одно и то же. Например, в английском, это слово — «digit» (произносится как «диджит»).

Надпись на латинском языке с использованием римских чисел на Арке Адмиралтейства в Лондоне гласит: ANNO : DECIMO : EDWARDI : SEPTIMI : REGIS : VICTORIÆ : REGINÆ : CIVES : GRATISSIMI : MDCCCCX : (На десятом году правления короля Эдуарда VII королеве Виктории от благодарных граждан, 1910 г.).
Надпись на латинском языке с использованием римских чисел на Арке Адмиралтейства в Лондоне гласит: ANNO : DECIMO : EDWARDI : SEPTIMI : REGIS : VICTORIÆ : REGINÆ : CIVES : GRATISSIMI : MDCCCCX : (На десятом году правления короля Эдуарда VII королеве Виктории от благодарных граждан, 1910 г.).
Римские цифры
Римские цифры использовались в Древнем Риме и Европе примерно до четырнадцатого столетия. Их до сих пор используют в некоторых контекстах, например на циферблатах часов, в именах Папы Римского, в названиях повторяющихся событий, например, олимпийских игр, и так далее. Римская система счисления использует семь букв латинского алфавита для обозначения всех возможных комбинаций чисел:

I	1
V	5
X	10
L	50
C	100
D	500
M	1000
Порядок написания цифр важен потому, что большее число слева от меньшего значит, что оба числа необходимо сложить, в то время как меньшее число слева от большего следует вычесть из большего числа. Например, XI равняется одиннадцати, а IX — это 9. Это правило действует только для чисел: IV, IX, XL, XC, CD и CM. В некоторых случаях эти правила не соблюдаются, и числа пишутся в ряд, например XXXXX.

Системы счисления в других культурах
Во многих культурах использовались системы счисления, похожие на римскую и арабскую. Например, в кириллической системе счисления цифры от одного до девяти, десять, и кратные ста писались буквами кириллицы. Также существовал специальный знак, похожий на тильду «~», который писали над такими цифрами, чтобы показать, что это не буквы. Существовала похожая система и с использованием глаголицы. В еврейской системе счисления буквами еврейского алфавита записывали числа от одного до десяти, кратные десяти, сто, двести, триста, и четыреста. Остальные числа писали как сумму или произведение. Греческая система счисления также похожа на все, приведенные выше.

В некоторых культурах системы счисления были проще. Например, вавилонские цифры можно было записать с помощью двух клинописных знаков, обозначавших единицу (похожего на большую букву «Т») и десять (похожего на букву «С»). Так, например, 32 можно записать как «СССТТ», используя соответствующие знаки. Египетская система счисления похожа, только в ней существовали также символы для нуля, сотни, тысячи, десяти тысяч, ста тысяч и миллиона, а также были специальные знаки для записи дробей. Цифры майя записывались с помощью знаков, обозначавших ноль, единицу и пятерку. Числа выше девятнадцати также имели своеобразное написание. В них использовались знаки для одного и пяти, но с другим расположением, чтобы показать, что значение этих цифр — другое.

Единичная система счисления. Счет с использованием черточек в разных культурах.
Единичная система счисления. Счет с использованием черточек в разных культурах.
Единичная система счисления
В единичной или унарной системе счисления используется только один знак, обозначающий единицу. Каждое число записывается с помощью таких знаков, количество которых равно этому числу. Например, если такой знак — буква «А», то число пять можно записать как «ААААА». Унарная система часто используется учителями, которые учат детей считать, потому что она помогает детям понять зависимость между количеством предметов, например счетных палочек или карандашей, и более абстрактного понятия числа. Часто унарную систему используют во время игр, чтобы записывать очки, набранные командами, или для счета дней или предметов. Причем метод записи в разных культурах отличается. Например, во многих странах, где принят латинский алфавит, чаще используются черточки. Обычно четыре вертикальные черточки перечеркивают горизонтальной или диагональной, и продолжают счет с новой группы черточек. В примере А) на рисунке счет доходит до четырех, эти черточки перечеркивают пятой, дальше добавляют еще пять черточек, и опять начинают новый ряд. Так, счет доходит до двенадцати. В странах, где в языке используют или использовали китайские иероглифы, люди обычно рисуют не четыре черточки, перечеркнутые пятой, а специальный иероглиф из пяти штрихов. Последовательность этих штрихов не произвольная, а установлена правилами правописания. В примере В) на рисунке счет доходит то пяти и человек пишет два первых штриха следующего иероглифа, заканчивая счет на семи. Кроме простого счета и учета, унарную систему также используют в компьютерных технологиях и электронике.

Арифмометр, в котором применяется десятичная позиционная система, и микросхема микропроцессора, использующего двоичную позиционную систему
Арифмометр, в котором применяется десятичная позиционная система, и микросхема микропроцессора, использующего двоичную позиционную систему
Позиционная система счисления
В позиционной системе счисления значение каждого знака, обозначающего цифру, зависит от его положения в числе. Это значение также зависит от основания системы счисления. Позиция обычно называется разрядом. Например, число 101 в двоичной системе не равно ста одному в десятичной. Рассмотрим позиционную систему на примере десятичной:

Первый разряд предназначен для единиц, то есть чисел от нуля до девяти. Цифра первого разряда умножается на десять в нулевой степени (то есть на единицу).
Второй разряд предназначен для десятков и цифру во втором разряде умножают на десять в первой степени.
Третий разряд предназначен для сотен и цифру в третьем разряде умножают на десять во второй степени, и так далее, пока не закончатся разряды.
Чтобы получить значение числа, складывают все числа, полученные выше, то есть значения чисел в каждом разряде. Такой способ написания чисел позволяет работать с большими числами, и не занимает так много места в тексте, по сравнению с непозиционными системами счисления.

Пример использования позиционирования в десятичной системе: 3102 = 3 × 10³ + 1 × 10² + 0 × 10¹ + 2 × 10⁰

Двоичная система
Двоичная система очень широко используется в математике и вычислительной технике. Все возможные числа представлены в ней с помощью только двух цифр, «0» и «1», хотя в некоторых случаях используют и другие знаки, например «+», «–». При переводе чисел из десятичной системы в двоичную получаем: 0=0, 1=1, а для дальнейшего перевода используют правила сложения. Сложение в двоичной системе основано на том же принципе, что и в десятичной. Чтобы добавить к числу единицу пользуются следующим правилом:

Художественное изображение чисел в двоичной системе
Художественное изображение чисел в двоичной системе
Для чисел оканчивающихся нулем, ноль заменяют единицей. Например: 100 (4) + 1 (1) = 101 (5). Здесь и далее для сравнения приведены десятичные числа в скобках.
В числе, оканчивающемся единицей, но не состоящем только из единиц, заменяют первый ноль справа на единицу, а все единицы, за ним следующие (справа от него) заменяют нулями. Например: 1011 (11) + 1 (1) = 1100.
В числе, состоящем из одних единиц, заменяют нулями все единицы, и в начале (слева) добавляют единицу. Например: 111 (7) + 1 (1) = 1000 (8).
При сложении пишут оба числа одно под другим, как при десятичном сложении. Правила при этом следующие: 0+0=0, 1+0=1, а 1+1=10, при этом в правом разряде пишут 0 и переносят 1 в следующий разряд. Например:

 11111 (31)
 +1011 (11)
———————————
101010 (42)
То есть, справа налево получаем:

1+1=0, один переносим в следующий разряд
1+1+1=1, один переносим в следующий разряд
1+1=0, один переносим в следующий разряд
1+1+1=1, один переносим в следующий разряд
1+1=10
То есть, получаем 101010.

Вычитание похоже на сложение, только вместо переноса, наоборот, «занимают» единицу из высших разрядов. Умножение тоже похоже на десятичное. Результат перемножения двух единиц — единица, а умножение на ноль дает ноль. Например:

  101  (5)
  ×10  (2)
———————————
  000
 101
———————————
 1010 (10)
Деление и взятие квадратного корня также мало отличается от работы с десятичными числами.

Классы чисел
Числа объединяются в классы, и некоторые числа могут одновременно входить в несколько классов.

Долг — отрицательное число
Долг — отрицательное число
Отрицательные числа
Отрицательные числа обозначают отрицательную величину. Перед ними ставят знак минус, чтобы отличить их от положительных. Например, если человек А должен человеку Б пять рублей, значит у него есть −5 рублей. Здесь –5 — отрицательное число.

Рациональные числа
Рациональные числа — это те числа, которые можно представить в виде дроби, где знаменатель — это положительное натуральное число, а числитель — целое число. Например, 3/4 и −10/5 (то есть, −2) — рациональные числа.

Натуральные числа
Натуральные числа это ноль и положительные целые числа. Например, 7 и 86 766 575 675 456 — натуральные числа.

Целые числа
Целые числа — это ноль, отрицательные и положительные числа, не являющиеся дробями. Например, −65 и 11 223 — целые числа.

Комплексные числа
Комплексные числа получают при сложении действительного (не комплексного) числа и другого действительного числа, умноженного на квадратный корень минус одного. Здесь квадратный корень минус одного называется мнимым числом.

Простые числа
Простые числа — это натуральные числа больше единицы, которые делятся без остатка только на единицу и сами себя. Примеры простых чисел это: 3, 5 и 11. 257 885 161−1 — самое большое известное простое число на февраль 2013 г. В нем содержится 17 425 170 цифр. Простые числа используют в криптосистемах с отрытым ключом. Это вид кодирования применяется в шифровании электронной информации в тех случаях, когда необходимо обеспечить информационную безопасность, например, на сайтах интернет-магазинов, электронных кошельков и банков.

Интересные факты о числах
Китайские иероглифы для предотвращения мошенничества
Китайские иероглифы для предотвращения мошенничества
Особая система записи чисел, чтобы предотвратить мошенничество
В Китае используют отдельную форму записи чисел для бизнеса и финансовых операций. Обычные иероглифы, используемые для названий чисел, слишком просты, и их легко подделать или переделать, добавив к ним всего несколько штрихов. Поэтому на банковских чеках и других финансовых документах обычно используют особые более сложные иероглифы.

Современный счет в торговле
В языках стран, где принята десятичная система счисления, до сих пор сохранились слова, свидетельствующие о том, что ранее там использовалась система с другой основой. Например, в английском языке до сих пор используют слово «дюжина», обозначающее двенадцать. Во многих англоязычных странах в дюжинах считают и продают яйца, мучные изделия, вино и цветы. А в кхмерском языке есть слова для счета фруктов, основанные на двадцатеричной системе.

Произношение названий чисел
Арабская система счисления применяется в Китае и Японии, но в отличие от английского, русского, и многих других языков, числа в китайском и японском языках сгруппированы по десять тысяч. То есть, когда в английском или в русском говорят: сто, потом идут кратные сотни, потом тысяча, кратные тысячи, миллион, и так далее, то в японском и китайском языках идут: сто, кратные ста до 9 999, десять тысяч, кратные десяти тысяч до 999 999, 1 000 000, и так далее.

Несчастливые числа
«Тайная вечеря» Леонардо да Винчи. Церковь Санта-Мария-делле-Грацие (Santa Maria delle Grazie), Милан, Италия.
«Тайная вечеря» Леонардо да Винчи. Церковь Санта-Мария-делле-Грацие (Santa Maria delle Grazie), Милан, Италия.
На Западе, а также во многих странах, где исповедуют христианство, 13 считается несчастливым числом. Историки считают, что это связано с христианством и иудаизмом. Согласно Библии, на Тайной Вечере присутствовало именно тринадцать учеников Иисуса, и тринадцатый, Иуда, после предал Христа. У викингов также существовало поверье о том, что когда тринадцать человек собираются вместе, один из них обязательно умрет в следующем году.

В странах, где говорят по-русски, неудачными считаются четные числа. Вероятно, это связано с верованиями древних славян, которые думали, что четные числа — статичны, неподвижны, закончены в одно целое, а значит — мертвые. Нечетные же, наоборот, подвижны, ищут дополнения, изменяются, а значит — живые. Поэтому четное количество цветов приносят только на похороны, но не дарят живым людям.

В Китае, Корее и Японии не любят число 4, потому, что оно созвучно со словом «смерть». Часто избегают не только саму цифру четыре, но и числа, ее содержащие. Например, часто пропускают такие числа в нумерации этажей и квартир. В Китае также не любят число 7, из-за того, что седьмой месяц в китайском календаре — месяц духов. Считается, что в этот месяц граница между мирами людей и духов исчезает, и духи приходят навещать людей. Число 9 считается неудачным в Японии, так как оно созвучно со словом «страдание».

Несчастливое число в Италии — 17, потому что его написание римскими цифрами — «XVII», что можно переписать как «VIXI», изменив порядок букв. Часто эта фраза была написана на могилах древних римлян и означала «я жил», поэтому ассоциируется с концом жизни и со смертью.

666 — известное многим несчастливое число, также именуемое «числом зверя» в Библии. Некоторые считают, что на самом деле «число зверя» — 616, но упоминание о 666 встречается чаще. Многие верят, что этим числом будет обозначен антихрист, наместник дьявола, и иногда ассоциируют это число с самим дьяволом. Так, некоторые убеждены, что 666 и 616 — это зашифрованное имя римского императора Нерона на древнееврейском и латинском языках соответственно, выраженное цифрами. Вероятность действительно существует, так как Нерон известен гонениями христиан и своим кровавым правлением. Некоторые историки даже считают, что именно Нерон являлся инициатором великого пожара Рима, хотя многие историки не согласны с такой трактовкой событий.

В Афганистане, особенно в Кабуле и его окрестностях, распространился слух о том, что число 39 — позорное число, связанное с проституцией. Согласно этому слуху, в Кабуле живет и работает сутенер, чей номерной знак на машине и номер квартиры содержит это число. Некоторые обвиняют правительство и организованные преступные группировки в том, что те специально распустили такой слух, чтобы покупать в Кабуле машины с такими номерными знаками и перепродавать в отдаленных провинциях, до куда не дошел этот слух. Людей с числом 39 в номерном знаке, номере квартиры или телефона дразнят, и насмехаются над ними, и эта проблема настолько серьезна, что многие изменяют цифры на номерных знаках и всячески стараются скрыть причастность к этому числу. Ходят слухи, что ненависть к числу 39 довела до трагедии. Во время выборов в парламент многие насмехались над кандидатом, чей номер в бюллетене был 39. Во время автомобильной пробки ему начали сигналить и кричать, в результате ситуация на дороге ухудшилась и переросла в аварию, и телохранители, опасающиеся за его жизнь, открыли огонь, в результате убив двоих. Парламентарий и его телохранители отрицают причастность к этому происшествию, никого не привлекли к ответственности, и неизвестно, произошло ли событие в действительности, или это только слухи.

Литература

Автор статьи: Kateryna Yuri

Перевести единицы: двоичное в десятичное

Перевести единицы: двоичное в основание 36

Перевести единицы: двоичное в шестнадцатеричное

Перевести единицы: десятичное в основание 36

Перевести единицы: десятичное в основание 32

Перевести единицы: шестнадцатеричное в десятичное

Перевести единицы: десятичное в основание 24

Перевести единицы: десятичное в основание 4

Перевести единицы: основание 3 в десятичное

Вас могут заинтересовать и другие конвертеры из группы «Популярные конвертеры единиц»:
Конвертер длины и расстояния

Конвертер массы

Конвертер мер объема сыпучих продуктов и продуктов питания

Конвертер площади

Конвертер объема и единиц измерения в кулинарных рецептах

Конвертер температуры

Конвертер давления, механического напряжения, модуля Юнга

Конвертер энергии и работы

Конвертер мощности

Конвертер силы

Конвертер времени

Конвертер линейной скорости

Плоский угол

Конвертер тепловой эффективности и топливной экономичности

Конвертер единиц измерения количества информации

Конвертер десятичных приставок

Передача данных

Курсы валют

Размеры мужской одежды и обуви

Размеры женской одежды и обуви

Компактный калькулятор Полный калькулятор Определения единиц
Unit pairs Онлайн-конвертеры единиц измерения Популярные конвертеры единиц
Вы затрудняетесь в переводе единицы измерения с одного языка на другой? Коллеги готовы вам помочь. Опубликуйте вопрос в TCTerms и в течение нескольких минут вы получите ответ.

Популярные конвертеры единиц
Конвертеры единиц измерения длины, массы, объема, температуры, давления, энергии, скорости и другие популярные конвертеры единиц измерения.
Конвертер чисел в различных системах счисления
Позиционная система счисления (позиционная нумерация)— система счисления, в которой значение каждого числового знака (цифры) в записи числа зависит от его позиции (разряда).

Основание 1 — единичная (унарная) система счисления; может рассматриваться как вырожденный случай позиционной системы счисления (счёт на пальцах, зарубки, узелки «на память» и др.);

Основание 2 — двоичная (в дискретной математике, информатике, программировании);

Основание 3 — троичная; иногда используется в вычислительной технике.

Основание 8 — восьмеричная;

Основание 10 — десятичная (используется повсеместно);

Основание 12 — двенадцатеричная (счёт дюжинами);

Основание 16 — шестнадцатеричная (используется в программировании, информатике);

Для записи чисел в системах счисления с основанием до 36 включительно в качестве цифр (знаков) используются арабские цифры (0—9) и, затем, прописные или строчные буквы латинского алфавита (A—Z). При этом, a = 10, b = 11 и т. д.

Использование конвертера «Конвертер чисел в различных системах счисления»
На этих страницах размещены конвертеры единиц измерения, позволяющие быстро и точно перевести значения из одних единиц в другие, а также из одной системы единиц в другую. Конвертеры пригодятся инженерам, переводчикам и всем, кто работает с разными единицами измерения.

Изучайте технический английский язык и технический русский язык с нашими видео! — Learn technical English and technical Russian with our videos!

Для представления очень больших и очень малых чисел в этом калькуляторе используется компьютерная экспоненциальная запись, являющаяся альтернативной формой нормализованной экспоненциальной (научной) записи, в которой числа записываются в форме a · 10x. Например: 1 103 000 = 1,103 · 106 = 1,103E+6. Здесь E (сокращение от exponent) — означает «· 10^», то есть «...умножить на десять в степени...». Компьютерная экспоненциальная запись широко используется в научных, математических и инженерных расчетах.

Выберите единицу, с которой выполняется преобразование, из левого списка единиц измерения.
Выберите единицу, в которую выполняется преобразование, из правого списка единиц измерения.
Введите число (например, «15») в поле «Исходная величина».
Результат сразу появится в поле «Результат» и в поле «Преобразованная величина».
Можно также ввести число в правое поле «Преобразованная величина» и считать результат преобразования в полях «Исходная величина» и «Результат».
JavaScript BigInteger Library

Мы работаем над обеспечением точности конвертеров и калькуляторов TranslatorsCafe.com, однако мы не можем гарантировать, что они не содержат ошибок и неточностей. Вся информация предоставляется «как есть», без каких-либо гарантий. Условия.

Если вы заметили неточность в расчётах или ошибку в тексте, или вам необходим другой конвертер для перевода из одной единицы измерения в другую, которого нет на нашем сайте — напишите нам!

Канал Конвертера единиц TranslatorsCafe.com на YouTube

TranslatorsCafe.com

Онлайн-конвертеры единиц измерения

Калькуляторы

Карта сайта

Мобильная версия

Установить конвертер
Язык интерфейса

English Deutsch Bahasa Indonesia Italiano Русский
Социальные сети:

Twitter Facebook Google+ VK
Рейтинг Alexa

Активных пользователей: 4392

Условия | Конфиденциальность

© ANVICA Software Development 2002—2020.

TC UC Version: 2017-02-01